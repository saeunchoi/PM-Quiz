<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Process Modeling 퀴즈</title>
    <style>
        /* CSS는 변경 없음 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 40px;
            max-width: 800px;
            width: 100%;
            min-height: 500px;
            position: relative;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2.2em;
        }
        
        .module-selector {
            display: flex;
            flex-wrap: wrap; /* 버튼이 많을 경우 줄바꿈 처리 */
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }
        
        .module-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .module-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .module-btn.active {
            background: linear-gradient(45deg, #2196F3, #1976D2);
        }
        
        .quiz-container {
            display: none;
        }
        
        .quiz-container.active {
            display: block;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 30px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .question-counter {
            background: #f0f0f0;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            color: #666;
        }
        
        .question {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border-left: 5px solid #2196F3;
        }
        
        .question h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.1em;
            line-height: 1.6;
        }
        
        .options {
            display: grid;
            gap: 12px;
        }
        
        .option {
            padding: 15px 20px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
        }
        
        .option:hover {
            border-color: #2196F3;
            background: #f0f8ff;
        }
        
        .option.selected {
            border-color: #2196F3;
            background: #e3f2fd;
        }
        
        .option.correct {
            border-color: #4CAF50;
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .option.incorrect {
            border-color: #f44336;
            background: #ffebee;
            color: #c62828;
        }
        
        .explanation {
            background: #fff3e0;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            border-left: 4px solid #ff9800;
            display: none;
        }
        
        .explanation.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        .explanation h4 {
            color: #e65100;
            margin-bottom: 10px;
        }
        
        .explanation p {
            line-height: 1.6;
            color: #555;
        }
        
        .next-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        .next-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .next-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results {
            text-align: center;
            padding: 40px 20px;
        }
        
        .results h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }
        
        .score {
            font-size: 3em;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .score.excellent { color: #4CAF50; }
        .score.good { color: #2196F3; }
        .score.average { color: #ff9800; }
        .score.poor { color: #f44336; }
        
        .restart-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .intro {
            text-align: center;
            padding: 20px;
        }
        
        .intro h2 {
            color: #333;
            margin-bottom: 20px;
        }
        
        .intro p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Process Modeling 퀴즈</h1>
        </div>
        
        <div class="intro" id="intro">
            <h2>모듈을 선택하여 퀴즈를 시작하세요</h2>
            <p>각 모듈별로 10-20문제가 출제되며, 문제를 풀자마자 정답과 상세 해설이 표시됩니다.</p>
        </div>
        
        <div class="module-selector">
            <button class="module-btn" onclick="startQuiz('module01', event)">Module 01: 프로세스 모델링 기초</button>
            <button class="module-btn" onclick="startQuiz('module02', event)">Module 02: RFP 및 제안서 작성</button>
            <button class="module-btn" onclick="startQuiz('module03', event)">Module 03: 프로세스 모델링 개요</button>
            <button class="module-btn" onclick="startQuiz('module04', event)">Module 04: 프로세스 모델링</button>
            <button class="module-btn" onclick="startQuiz('module05', event)">Module 05: Function Point</button>
            <button class="module-btn" onclick="startQuiz('module06', event)">Module 06: SW 테스트</button>
            <button class="module-btn" onclick="startQuiz('module07', event)">Module 07: SW 개발방법론</button>
        </div>
        
        <div class="quiz-container" id="quiz-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            
            <div class="question-header">
                <div class="question-counter">
                    <span id="current-question">1</span> / <span id="total-questions">15</span>
                </div>
            </div>
            
            <div class="question" id="question-container">
            </div>
            
            <button class="next-btn" id="next-btn" onclick="nextQuestion()" disabled>다음 문제</button>
        </div>
        
        <div class="results" id="results" style="display: none;">
        </div>
    </div>

    <script>
        // ✨ 수정된 부분: 세미콜론(;)을 쉼표(,)로 변경하여 올바른 객체 문법으로 수정
        const quizData = {
            module06: [
                {
                    question: "SW 테스트의 주요 목적이 아닌 것은?",
                    options: ["결함 발견", "요구사항 충족 여부 검증", "개발 속도 향상", "품질 개선"],
                    correct: 2,
                    explanation: "SW 테스트의 주요 목적은 결함 발견, 요구사항 충족 여부 검증, 품질 개선, 위험 감소, 신뢰성 향상입니다. 개발 속도 향상은 테스트의 직접적인 목적이 아닙니다."
                },
                {
                    question: "SW 테스트 수행 절차의 올바른 순서는?",
                    options: [
                        "테스트 실행 → 테스트 계획 수립 → 사용자 요구 분석 → 테스트 케이스 설계",
                        "사용자 요구 분석 → 테스트 계획 수립 → 테스트 케이스 설계 → 테스트 실행",
                        "테스트 케이스 설계 → 테스트 계획 수립 → 사용자 요구 분석 → 테스트 실행",
                        "테스트 계획 수립 → 사용자 요구 분석 → 테스트 실행 → 테스트 케이스 설계"
                    ],
                    correct: 1,
                    explanation: "SW 테스트 수행 절차는 사용자 요구 분석 → 테스트 계획 수립 → 테스트 케이스 설계 → 테스트 실행 → 테스트 결함 관리의 순서로 진행됩니다."
                },
                {
                    question: "테스트 시나리오와 테스트 케이스의 차이점으로 올바른 것은?",
                    options: [
                        "테스트 시나리오가 더 구체적이고 상세하다",
                        "테스트 케이스가 더 포괄적이고 개념적이다",
                        "테스트 시나리오는 포괄적 설명, 테스트 케이스는 상세한 명세",
                        "둘 다 동일한 의미이다"
                    ],
                    correct: 2,
                    explanation: "테스트 시나리오는 '특정 기능이나 시스템의 동작을 검증하기 위한 일련의 조건이나 단계에 대한 포괄적인 설명'이고, 테스트 케이스는 '입력값, 예상 출력값, 테스트 환경, 사전 조건 및 사후 조건 등을 명시한 상세한 명세'입니다."
                },
                {
                    question: "단위 테스트에 대한 설명으로 옳지 않은 것은?",
                    options: [
                        "개발자가 직접 코드를 작성하여 테스트한다",
                        "모듈 간의 인터페이스를 중점적으로 테스트한다",
                        "JUnit과 같은 자동화 프레임워크를 활용한다",
                        "코드의 가장 작은 단위가 의도대로 동작하는지 검증한다"
                    ],
                    correct: 1,
                    explanation: "단위 테스트는 개발자가 작성한 코드의 가장 작은 단위(모듈, 함수 등)를 테스트하는 것입니다. 모듈 간의 인터페이스를 중점적으로 테스트하는 것은 통합 테스트의 목적입니다."
                },
                {
                    question: "통합 테스트의 설계 방법으로 활용되지 않는 것은?",
                    options: ["업무 기능 분해도", "업무 흐름도", "요구사항 정의서", "코드 커버리지 분석"],
                    correct: 3,
                    explanation: "통합 테스트 설계 방법으로는 업무 기능 분해도, 업무 흐름도, 요구사항 정의서, 단위 테스트 케이스 등이 활용됩니다. 코드 커버리지 분석은 단위 테스트에서 주로 사용되는 기법입니다."
                },
                {
                    question: "통합 테스트의 수행 방식이 아닌 것은?",
                    options: ["상향식(Bottom-Up)", "하향식(Top-Down)", "샌드위치(Sandwich)", "순환식(Circular)"],
                    correct: 3,
                    explanation: "통합 테스트의 수행 방식에는 상향식(Bottom-Up), 하향식(Top-Down), 샌드위치(Sandwich) 방식이 있습니다. 순환식(Circular)은 통합 테스트의 공식적인 수행 방식이 아닙니다."
                },
                {
                    question: "인수 테스트의 유형이 아닌 것은?",
                    options: ["사용자 인수 테스트(UAT)", "운영 인수 테스트(OAT)", "계약 인수 테스트(CAT)", "단위 인수 테스트(UIT)"],
                    correct: 3,
                    explanation: "인수 테스트의 유형에는 사용자 인수 테스트(UAT), 운영 인수 테스트(OAT), 계약 인수 테스트(CAT), 규제 인수 테스트(RAT) 등이 있습니다. 단위 인수 테스트(UIT)는 존재하지 않는 용어입니다."
                },
                {
                    question: "테스트 데이터의 특성으로 옳지 않은 것은?",
                    options: [
                        "본래 값을 추측할 수 없도록 스크램블링되어야 한다",
                        "애플리케이션 체크 로직을 통과할 수 있어야 한다",
                        "운영 가능한 범위 내에서 생성되어야 한다",
                        "실제 운영 데이터를 그대로 사용해야 한다"
                    ],
                    correct: 3,
                    explanation: "테스트 데이터는 본래 값을 추측할 수 없도록 스크램블링하고, 애플리케이션 체크 로직을 통과할 수 있어야 하며, 운영 가능한 범위 내에서 생성되어야 합니다. 실제 운영 데이터를 그대로 사용하는 것은 보안상 위험합니다."
                },
                {
                    question: "단위 테스트에서 중점적으로 테스트하는 항목이 아닌 것은?",
                    options: ["인터페이스", "수행 경로", "모듈 간 데이터 흐름", "자료 구조"],
                    correct: 2,
                    explanation: "단위 테스트에서는 인터페이스, 수행 경로, 오류 처리, 자료 구조, 경곗값 등을 중점적으로 테스트합니다. 모듈 간 데이터 흐름은 통합 테스트에서 다루는 영역입니다."
                },
                {
                    question: "통합 테스트에서 사용되는 테스트 케이스 설계 기법은?",
                    options: [
                        "균등 분할 기법과 경곗값 분석 기법",
                        "화이트박스 테스트 기법만",
                        "블랙박스 테스트 기법만",
                        "랜덤 테스트 기법"
                    ],
                    correct: 0,
                    explanation: "통합 테스트에서는 균등 분할 기법과 경곗값 분석 기법을 사용하여 테스트 케이스를 설계합니다. 이는 입력 데이터를 효과적으로 분할하여 테스트하는 기법입니다."
                },
                {
                    question: "인수 테스트의 주요 인수 기준이 아닌 것은?",
                    options: ["기능적 요구사항 충족", "성능 요구사항 충족", "코드 복잡도 최소화", "보안 요구사항 충족"],
                    correct: 2,
                    explanation: "인수 테스트의 주요 인수 기준에는 기능적 요구사항 충족, 성능 요구사항 충족, 보안 요구사항 충족, 사용성 및 접근성, 데이터 무결성 및 정확성 등이 있습니다. 코드 복잡도 최소화는 개발 품질 기준이지 인수 기준이 아닙니다."
                },
                {
                    question: "테스트 레벨의 올바른 순서는?",
                    options: [
                        "통합 테스트 → 단위 테스트 → 시스템 테스트 → 인수 테스트",
                        "단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트",
                        "시스템 테스트 → 통합 테스트 → 단위 테스트 → 인수 테스트",
                        "인수 테스트 → 시스템 테스트 → 통합 테스트 → 단위 테스트"
                    ],
                    correct: 1,
                    explanation: "테스트 레벨은 일반적으로 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트 순서로 진행됩니다. 이는 작은 단위부터 전체 시스템까지 점진적으로 확장하는 방식입니다."
                },
                {
                    question: "SW 테스트에서 '결함 관리'의 주요 활동이 아닌 것은?",
                    options: ["결함 발견 및 기록", "결함 분석 및 분류", "결함 수정 및 재테스트", "결함 예방을 위한 코드 작성"],
                    correct: 3,
                    explanation: "결함 관리의 주요 활동에는 결함 발견 및 기록, 결함 분석 및 분류, 결함 수정 및 재테스트, 결함 추적 등이 있습니다. 결함 예방을 위한 코드 작성은 개발 활동이지 테스트 결함 관리 활동이 아닙니다."
                },
                {
                    question: "테스트 케이스에 포함되어야 하는 요소가 아닌 것은?",
                    options: ["입력값", "예상 출력값", "테스트 환경", "개발자 정보"],
                    correct: 3,
                    explanation: "테스트 케이스에는 입력값, 예상 출력값, 테스트 환경, 사전 조건 및 사후 조건 등이 포함되어야 합니다. 개발자 정보는 테스트 케이스의 필수 요소가 아닙니다."
                },
                {
                    question: "통합 테스트의 주요 목적은?",
                    options: [
                        "개별 모듈의 기능 검증",
                        "모듈 간 인터페이스 관련 결함 발견",
                        "사용자 요구사항 충족 확인",
                        "시스템 성능 측정"
                    ],
                    correct: 1,
                    explanation: "통합 테스트의 주요 목적은 모듈 간의 체계적인 조합 과정에서 발생하는 인터페이스 관련 결함을 발견하고 제거하는 것입니다."
                }
            ],
            module07: [
                {
                    question: "SW 개발방법론의 정의로 가장 적절한 것은?",
                    options: [
                        "소프트웨어를 빠르게 개발하기 위한 도구",
                        "소프트웨어 개발 프로젝트를 체계적이고 효율적으로 수행하기 위한 일련의 절차, 기법, 도구 및 지침의 집합",
                        "프로그래밍 언어를 선택하는 기준",
                        "소프트웨어 테스트를 자동화하는 방법"
                    ],
                    correct: 1,
                    explanation: "SW 개발방법론은 '소프트웨어 개발 프로젝트를 체계적이고 효율적으로 수행하기 위한 일련의 절차, 기법, 도구 및 지침의 집합'입니다. SDLC의 모든 단계에 걸쳐 개발 과정을 체계적으로 관리합니다."
                },
                {
                    question: "SW 개발방법론의 진화 순서로 올바른 것은?",
                    options: [
                        "애자일 → 객체지향 → 구조적",
                        "구조적 → 애자일 → 객체지향",
                        "객체지향 → 구조적 → 애자일",
                        "구조적 → 객체지향 → 애자일"
                    ],
                    correct: 3,
                    explanation: "SW 개발방법론은 전통적인 구조적 방법론(폭포수 모델)에서 객체지향 방법론을 거쳐 애자일 방법론으로 발전해왔습니다."
                },
                {
                    question: "폭포수(Waterfall) 모델의 특징이 아닌 것은?",
                    options: [
                        "각 개발 단계가 순차적으로 진행된다",
                        "이전 단계가 완료되어야 다음 단계로 넘어간다",
                        "요구사항 변경에 유연하게 대응한다",
                        "각 단계가 명확하고 문서화가 철저하다"
                    ],
                    correct: 2,
                    explanation: "폭포수 모델은 각 단계가 순차적으로 진행되는 선형적인 개발 모델로, 각 단계가 명확하고 문서화가 철저하다는 장점이 있지만, 요구사항 변경에 취약하고 피드백 반영이 어렵다는 단점이 있습니다."
                },
                {
                    question: "객체지향 방법론의 장점이 아닌 것은?",
                    options: ["재사용성", "유지보수성", "확장성", "개발 속도"],
                    correct: 3,
                    explanation: "객체지향 방법론의 장점으로는 재사용성, 유지보수성, 확장성이 뛰어나다는 점이 있습니다. 개발 속도는 객체지향 방법론의 주요 장점으로 언급되지 않습니다."
                },
                {
                    question: "애자일 방법론의 핵심 가치가 아닌 것은?",
                    options: [
                        "개인과 상호작용이 프로세스와 도구보다 중요",
                        "작동하는 소프트웨어가 포괄적인 문서보다 중요",
                        "계약 협상이 고객과의 협력보다 중요",
                        "변화에 대한 반응이 계획을 따르는 것보다 중요"
                    ],
                    correct: 2,
                    explanation: "애자일 방법론의 핵심 가치는 '고객과의 협력이 계약 협상보다 중요'합니다. 계약 협상이 고객과의 협력보다 중요하다는 것은 애자일 가치와 반대됩니다."
                },
                {
                    question: "애자일과 전통적 개발방법론의 비교에서 올바른 것은?",
                    options: [
                        "애자일: 계획 중심, 전통적: 적응 중심",
                        "애자일: 문서 중심, 전통적: 코드 중심",
                        "애자일: 적응 중심, 전통적: 계획 중심",
                        "애자일: 후반 피드백, 전통적: 지속적 피드백"
                    ],
                    correct: 2,
                    explanation: "애자일은 적응 중심이고 전통적 방법론은 계획 중심입니다. 애자일은 초기 계획보다는 변화에 대한 적응을 강조합니다."
                },
                {
                    question: "스크럼(SCRUM)에서 '스프린트'의 일반적인 기간은?",
                    options: ["1일", "1~4주", "1~6개월", "1년"],
                    correct: 1,
                    explanation: "스프린트는 짧은 고정된 시간 주기로 보통 1~4주 내에 제품을 개발하는 반복 단위입니다."
                },
                {
                    question: "스크럼에서 '프로덕트 백로그'는 무엇인가?",
                    options: [
                        "완료된 기능 목록",
                        "개발할 기능 목록",
                        "발견된 버그 목록",
                        "팀원들의 작업 일정"
                    ],
                    correct: 1,
                    explanation: "프로덕트 백로그(Product Backlog)는 개발할 기능 목록을 의미합니다. 제품의 요구사항들이 우선순위에 따라 정리된 목록입니다."
                },
                {
                    question: "스크럼 팀의 역할이 아닌 것은?",
                    options: ["프로덕트 오너", "스크럼 마스터", "개발 팀", "프로젝트 매니저"],
                    correct: 3,
                    explanation: "스크럼 팀의 역할에는 프로덕트 오너(Product Owner), 스크럼 마스터(Scrum Master), 개발 팀(Development Team)이 있습니다. 프로젝트 매니저는 전통적인 프로젝트 관리 역할로 스크럼 팀의 공식적인 역할이 아닙니다."
                },
                {
                    question: "프로덕트 오너(Product Owner)의 주요 역할은?",
                    options: [
                        "코드 작성 및 테스트",
                        "팀의 스크럼 프로세스 준수 지원",
                        "제품의 비전과 가치를 정의하고 백로그 우선순위 관리",
                        "일일 스크럼 회의 주관"
                    ],
                    correct: 2,
                    explanation: "프로덕트 오너는 제품의 비전과 가치를 정의하고 백로그 우선순위를 관리하는 역할을 담당합니다. 제품의 방향성을 결정하는 핵심 역할입니다."
                },
                {
                    question: "스크럼 마스터(Scrum Master)의 주요 역할은?",
                    options: [
                        "제품 기능 우선순위 결정",
                        "팀의 스크럼 프로세스 준수 지원 및 장애물 제거",
                        "코드 리뷰 및 품질 관리",
                        "고객과의 계약 협상"
                    ],
                    correct: 1,
                    explanation: "스크럼 마스터는 팀의 스크럼 프로세스 준수를 지원하고 장애물을 제거하는 역할을 담당합니다. 팀이 스크럼을 효과적으로 실행할 수 있도록 돕는 서번트 리더입니다."
                },
                {
                    question: "일일 스크럼(Daily Scrum)의 주요 목적은?",
                    options: [
                        "상세한 기술 설계 논의",
                        "진척 상황 공유 및 문제점 식별",
                        "성과 평가 및 보상 결정",
                        "새로운 요구사항 수집"
                    ],
                    correct: 1,
                    explanation: "일일 스크럼은 매일 진행되는 짧은 회의로, 팀원들이 진척 상황을 공유하고 문제점을 식별하는 것이 주요 목적입니다."
                },
                {
                    question: "스프린트 백로그(Sprint Backlog)는 무엇인가?",
                    options: [
                        "전체 프로젝트의 요구사항 목록",
                        "스프린트 목표 달성을 위해 선택된 프로덕트 백로그 항목과 태스크 목록",
                        "완료된 작업 목록",
                        "다음 스프린트 계획안"
                    ],
                    correct: 1,
                    explanation: "스프린트 백로그는 스프린트 목표 달성을 위해 선택된 프로덕트 백로그 항목과 이를 구현하기 위한 태스크 목록입니다."
                },
                {
                    question: "스프린트 리뷰(Sprint Review)의 목적은?",
                    options: [
                        "팀원들의 개인 성과 평가",
                        "스프린트 결과물 시연 및 피드백",
                        "다음 스프린트 계획 수립",
                        "프로세스 개선 방안 논의"
                    ],
                    correct: 1,
                    explanation: "스프린트 리뷰는 스프린트 결과물을 시연하고 이해관계자들로부터 피드백을 받는 것이 목적입니다."
                },
                {
                    question: "스프린트 회고(Sprint Retrospective)의 목적은?",
                    options: [
                        "제품 기능 시연",
                        "고객 피드백 수집",
                        "프로세스 개선을 위한 팀 회고",
                        "다음 스프린트 백로그 선정"
                    ],
                    correct: 2,
                    explanation: "스프린트 회고는 프로세스 개선을 위한 팀 회고 시간으로, 팀이 더 효과적으로 일할 수 있는 방법을 찾는 것이 목적입니다."
                },
                {
                    question: "구조적 방법론에서 주로 사용되는 도구가 아닌 것은?",
                    options: ["데이터 흐름도(DFD)", "구조도(Structure Chart)", "UML 다이어그램", "처리 명세서"],
                    correct: 2,
                    explanation: "구조적 방법론에서는 데이터 흐름도(DFD), 구조도(Structure Chart) 등을 주로 사용합니다. UML 다이어그램은 객체지향 방법론에서 사용되는 도구입니다."
                },
                {
                    question: "객체지향 방법론과 구조적 방법론의 차이점으로 올바른 것은?",
                    options: [
                        "객체지향은 기능 중심, 구조적은 데이터 중심",
                        "객체지향은 데이터와 기능을 분리, 구조적은 통합",
                        "객체지향은 데이터와 기능을 하나의 객체로 통합, 구조적은 기능 중심으로 분할",
                        "둘 다 동일한 접근 방식"
                    ],
                    correct: 2,
                    explanation: "객체지향 방법론은 데이터와 기능을 하나의 객체로 묶어 관리하는 반면, 구조적 방법론은 소프트웨어 개발을 기능 중심으로 분할하고 논리적인 구조와 절차에 따라 개발합니다."
                },
                {
                    question: "애자일 방법론 적용 시 고려사항이 아닌 것은?",
                    options: [
                        "팀원 간의 강한 협업과 의사소통이 필요",
                        "변화에 대한 유연한 태도가 필요",
                        "모든 프로젝트에 적합하다",
                        "고객과의 지속적인 협력이 필요"
                    ],
                    correct: 2,
                    explanation: "애자일 방법론은 모든 프로젝트에 적합하지 않습니다. 팀원 간의 강한 협업과 의사소통, 변화에 대한 유연한 태도가 요구되며, 프로젝트의 특성을 고려하여 적용해야 합니다."
                },
                {
                    question: "SW 개발방법론이 다루는 영역이 아닌 것은?",
                    options: ["프로젝트 관리", "요구사항 관리", "하드웨어 설계", "테스트"],
                    correct: 2,
                    explanation: "SW 개발방법론은 프로젝트 관리, 요구사항 관리, 설계, 구현, 테스트, 배포 및 유지보수 등 SDLC의 모든 단계를 다룹니다. 하드웨어 설계는 소프트웨어 개발방법론의 직접적인 영역이 아닙니다."
                }
            ],
            module04: [    
                {
                    question: "프로세스 모델링에서 업무 구성도의 주요 목적은 무엇인가요?",
                    options: [
                        "업무 프로세스 간의 순서를 정의하는 것",
                        "시스템의 범위를 명확히 하고 외부와의 상호작용을 표현하는 것",
                        "업무의 최소 단위를 도출하는 것",
                        "비즈니스 로직을 상세히 기술하는 것"
                    ],
                    correct: 1,
                    explanation: "업무 구성도는 시스템의 범위(Scope)를 명확히 하고 외부와의 상호작용(Interface)을 표현하는 다이어그램입니다. 시스템 업무 범위 파악 및 타 시스템과의 상호작용 파악에 사용됩니다."
                },
                {
                    question: "업무 기능 분해도 작성 시 적용되는 MECE 원칙이 의미하는 것은?",
                    options: [
                        "Maximum Efficiency Collective Enhancement",
                        "Mutually Exclusive Collectively Exhaustive",
                        "Minimum Error Correction Execution",
                        "Multiple Entry Collaborative Execution"
                    ],
                    correct: 1,
                    explanation: "MECE는 Mutually Exclusive Collectively Exhaustive의 약자로, '상호 배타적이면서 전체적으로 포괄적'이라는 의미입니다. 업무 기능을 중복 없이 빠짐없이 분류하는 원칙입니다."
                },
                {
                    question: "업무 흐름도의 활용 목적으로 적절하지 않은 것은?",
                    options: [
                        "시스템 지원 프로세스 여부 확인",
                        "통합 테스트 시나리오 도출",
                        "신규 투입 인력 업무 파악",
                        "데이터베이스 테이블 구조 설계"
                    ],
                    correct: 3,
                    explanation: "업무 흐름도는 업무 프로세스 간의 선후행 관계와 정보 흐름을 나타내며, 시스템 지원 프로세스 확인, 통합 테스트 시나리오 도출, 신규 인력 업무 파악 등에 활용됩니다. 데이터베이스 테이블 구조 설계는 데이터 모델링 영역입니다."
                },
                {
                    question: "UI 설계 시 웹/모바일 접근성 원칙에 포함되지 않는 것은?",
                    options: [
                        "인식의 용이성",
                        "운용의 용이성",
                        "이해의 용이성",
                        "확장의 용이성"
                    ],
                    correct: 3,
                    explanation: "웹/모바일 접근성 원칙은 인식의 용이성, 운용의 용이성, 이해의 용이성, 견고성 4가지입니다. 확장의 용이성은 접근성 원칙에 포함되지 않습니다."
                },
                {
                    question: "정보 구조도(IA) 설계 시 권장되는 기준은?",
                    options: [
                        "폭 5개 내외, 깊이 3단계 이하",
                        "폭 7개 내외, 깊이 4~5단계 이하",
                        "폭 10개 내외, 깊이 6~7단계 이하",
                        "폭과 깊이에 제한 없음"
                    ],
                    correct: 1,
                    explanation: "정보 구조도 설계 시 폭(옵션 수)은 7개 내외, 깊이(계층 단계 수)는 4~5단계 이하로 설계하는 것이 바람직합니다. 이는 사용자의 인지 부하를 줄이고 탐색을 용이하게 합니다."
                },
                {
                    question: "비즈니스 로직 설계에서 수행하는 작업이 아닌 것은?",
                    options: [
                        "비즈니스 클래스 로직 작성",
                        "모듈화 반영",
                        "SW 아키텍처 반영",
                        "사용자 인터페이스 프로토타입 제작"
                    ],
                    correct: 3,
                    explanation: "비즈니스 로직 설계는 서버 측의 비즈니스 로직을 상세히 기술하는 작업으로, 비즈니스 클래스 로직 작성, 모듈화 반영, SW 아키텍처 반영 등을 포함합니다. 사용자 인터페이스 프로토타입 제작은 화면 설계 영역입니다."
                },
                {
                    question: "인터페이스 통신 방법에 해당하지 않는 것은?",
                    options: [
                        "Http",
                        "Socket",
                        "Web Service",
                        "MECE"
                    ],
                    correct: 3,
                    explanation: "인터페이스 통신 방법에는 Http, Socket, FTP, Web Service, DB Link 등이 있습니다. MECE는 업무 기능 분해도 작성 시 적용되는 원칙으로 통신 방법이 아닙니다."
                },
                {
                    question: "인터페이스 전송 방식의 종류로 올바른 것은?",
                    options: [
                        "단방향, 양방향, 다방향",
                        "실시간, 배치, 지연 처리",
                        "동기, 비동기, 준동기",
                        "내부, 외부, 혼합"
                    ],
                    correct: 1,
                    explanation: "인터페이스 전송 방식에는 실시간, 배치, 지연 처리 등이 있습니다. 단방향/양방향은 통신 유형이고, 내부/외부는 인터페이스 구분입니다."
                },
                {
                    question: "UI 흐름 설계와 UI 상세 설계의 차이점으로 올바른 것은?",
                    options: [
                        "UI 흐름 설계는 데이터 구조를, UI 상세 설계는 비즈니스 로직을 다룬다",
                        "UI 흐름 설계는 화면 간 전환을, UI 상세 설계는 각 화면의 구성 요소를 다룬다",
                        "UI 흐름 설계는 백엔드를, UI 상세 설계는 프론트엔드를 다룬다",
                        "두 설계 간에는 본질적인 차이가 없다"
                    ],
                    correct: 1,
                    explanation: "UI 흐름 설계는 화면 간의 전환 및 사용자 시나리오 흐름을 나타내고, UI 상세 설계는 각 화면의 구성 요소, 동작, 예외 처리 등을 구체적으로 기술합니다."
                },
                {
                    question: "프로세스 모델링의 올바른 진행 순서는?",
                    options: [
                        "업무 흐름도 → 업무 구성도 → 업무 기능 분해도 → 통합 업무 흐름도",
                        "업무 구성도 → 업무 기능 분해도 → 업무 흐름도 → 통합 업무 흐름도",
                        "업무 기능 분해도 → 업무 구성도 → 통합 업무 흐름도 → 업무 흐름도",
                        "통합 업무 흐름도 → 업무 흐름도 → 업무 기능 분해도 → 업무 구성도"
                    ],
                    correct: 1,
                    explanation: "프로세스 모델링은 업무 구성도 작성 → 업무 기능 분해도 작성 → 업무 흐름도 작성 → 통합 업무 흐름도 작성 순으로 진행됩니다."
                },
                {
                    question: "인터페이스 데이터 형식으로 사용되지 않는 것은?",
                    options: [
                        "Fixed Length",
                        "JSON",
                        "XML",
                        "MECE"
                    ],
                    correct: 3,
                    explanation: "인터페이스 데이터 형식에는 Fixed Length, Delimiter, JSON, XML 등이 있습니다. MECE는 업무 기능 분해 원칙으로 데이터 형식이 아닙니다."
                },
                {
                    question: "UI 설계의 설계 원칙에 포함되지 않는 것은?",
                    options: [
                        "일관성, 유연성",
                        "효율성, 명확성",
                        "가독성, 사용성",
                        "복잡성, 다양성"
                    ],
                    correct: 3,
                    explanation: "UI 설계 원칙에는 일관성, 유연성, 효율성, 명확성, 가독성, 사용성, 접근성 등이 포함됩니다. 복잡성과 다양성은 UI 설계에서 지양해야 할 요소입니다."
                }
            ],
            module05: [    
                {
                    question: "Function Point의 정의로 가장 적절한 것은?",
                    options: [
                        "프로그래밍 언어별 코드 라인 수를 측정하는 방법",
                        "사용자 관점에서 소프트웨어 기능을 정량적으로 산정하는 방법",
                        "시스템 성능을 측정하는 지표",
                        "개발자의 생산성을 평가하는 척도"
                    ],
                    correct: 1,
                    explanation: "Function Point는 '사용자 관점에서의 사용자가 요구하고 사용자에게 인도되는 기능을 정량적으로 산정하는 소프트웨어 규모 측정방법'입니다."
                },
                {
                    question: "ILF(Internal Logical File)의 정의로 올바른 것은?",
                    options: [
                        "외부 시스템에서 참조하는 데이터",
                        "측정 대상 애플리케이션 경계 내부에 유지되는 논리적 데이터 그룹",
                        "애플리케이션 경계 외부로 출력되는 데이터",
                        "시스템 간 인터페이스를 위한 데이터"
                    ],
                    correct: 1,
                    explanation: "ILF(Internal Logical File)는 사용자가 식별할 수 있는 논리적으로 연관된 데이터 그룹 또는 제어 정보로 측정 대상 애플리케이션 경계 내부에 유지되는 데이터입니다."
                },
                {
                    question: "EIF(External Interface File)와 ILF의 차이점은?",
                    options: [
                        "EIF는 입력 데이터, ILF는 출력 데이터",
                        "EIF는 외부 시스템의 데이터를 참조, ILF는 내부에서 유지되는 데이터",
                        "EIF는 정적 데이터, ILF는 동적 데이터",
                        "EIF는 단순 조회, ILF는 복잡 처리"
                    ],
                    correct: 1,
                    explanation: "EIF는 측정 대상 애플리케이션 경계 내의 하나 이상의 단위 프로세스를 통해 참조된 데이터를 보관하는 외부 시스템의 데이터이고, ILF는 애플리케이션 경계 내부에 유지되는 데이터입니다."
                },
                {
                    question: "EO(External Output)의 특징으로 올바른 것은?",
                    options: [
                        "단순히 데이터를 조회하여 출력하는 기능",
                        "외부에서 데이터를 입력받는 기능",
                        "평균, 합계 등 파생 데이터를 생성하거나 ILF를 갱신하는 기능",
                        "외부 시스템의 파일을 참조하는 기능"
                    ],
                    correct: 2,
                    explanation: "EO(External Output)는 평균, 합계 등 기타 수식에 의해 계산된 파생 데이터를 사용하거나, 하나 이상의 ILF를 갱신하거나, 파생 데이터를 생성하는 처리 로직을 포함합니다."
                },
                {
                    question: "EQ(External Inquiry)의 정의로 올바른 것은?",
                    options: [
                        "복잡한 계산을 통해 데이터를 출력하는 기능",
                        "ILF, EIF를 단순 조회하여 애플리케이션 경계 외부로 출력하는 기능",
                        "외부에서 데이터를 입력받아 처리하는 기능",
                        "시스템 내부 데이터를 갱신하는 기능"
                    ],
                    correct: 1,
                    explanation: "EQ(External Inquiry)는 ILF, EIF를 단순 조회하여 애플리케이션 경계 외부로 출력하는 기능입니다."
                },
                {
                    question: "Function Point의 5가지 구성 요소 중 데이터 기능에 해당하는 것은?",
                    options: [
                        "EI, EO",
                        "ILF, EIF",
                        "EQ, EI",
                        "EO, EQ"
                    ],
                    correct: 1,
                    explanation: "Function Point의 구성 요소 중 데이터 기능(Data Functions)에는 ILF(Internal Logical File)와 EIF(External Interface File)가 있습니다."
                },
                {
                    question: "트랜잭션 기능(Transactional Functions)에 포함되는 것은?",
                    options: [
                        "ILF, EIF, EI",
                        "EI, EO, EQ",
                        "ILF, EO, EQ",
                        "EIF, EI, EO"
                    ],
                    correct: 1,
                    explanation: "트랜잭션 기능(Transactional Functions)에는 EI(External Input), EO(External Output), EQ(External Inquiry)가 포함됩니다."
                },
                {
                    question: "SW 개발비 산정에서 기능점수 방식의 공식은?",
                    options: [
                        "기능점수 X 기능점수 단가",
                        "(기능점수 X 기능점수 단가 X 보정계수) + 직접 경비 + 이윤",
                        "기능점수 + 직접 경비 + 이윤",
                        "기능점수 X 보정계수"
                    ],
                    correct: 1,
                    explanation: "SW 개발비 산정에서 기능점수 방식은 '(기능점수 X 기능점수 단가 X 보정계수) + 직접 경비 + 이윤'으로 산정됩니다."
                },
                {
                    question: "Function Point 측정의 특징으로 올바르지 않은 것은?",
                    options: [
                        "특정 프로그래밍 언어에 종속적이지 않음",
                        "기능의 규모와 복잡도에 기반하여 산정",
                        "소프트웨어 개발 비용 산정 가능",
                        "코드 라인 수에 비례하여 산정"
                    ],
                    correct: 3,
                    explanation: "Function Point는 특정 프로그래밍 언어에 종속적이지 않고 기능의 규모와 복잡도에 기반하여 산정됩니다. 코드 라인 수와는 직접적인 관련이 없습니다."
                },
                {
                    question: "EI(External Input)의 특징으로 올바른 것은?",
                    options: [
                        "단순히 데이터를 조회하는 기능",
                        "하나 이상의 ILF를 유지하거나 애플리케이션 동작을 변경하는 기능",
                        "파생 데이터를 생성하는 기능",
                        "외부 시스템의 파일을 참조하는 기능"
                    ],
                    correct: 1,
                    explanation: "EI(External Input)는 하나 이상의 ILF를 유지하거나, 애플리케이션의 동작을 변경하기 위해 경계 내부로 유입되는 데이터나 제어 정보를 수신하는 처리 로직을 포함합니다."
                },
                {
                    question: "Function Point가 ISO/IEC 14143으로 표준화된 이유는?",
                    options: [
                        "프로그래밍 언어 표준화를 위해",
                        "SW Size 산정을 위한 국제표준으로 사용하기 위해",
                        "데이터베이스 설계 표준화를 위해",
                        "네트워크 프로토콜 표준화를 위해"
                    ],
                    correct: 1,
                    explanation: "Function Point는 ISO/IEC 14143(FSM; Functional Size Measurement)으로 SW Size 산정을 위한 국제표준으로 제정되었습니다."
                },
                {
                    question: "SW사업 대가산정 가이드에서 적용되는 보정계수는?",
                    options: [
                        "언어 보정계수, 플랫폼 보정계수",
                        "규모 보정계수, 애플리케이션 복잡도 보정계수",
                        "성능 보정계수, 보안 보정계수",
                        "개발자 보정계수, 일정 보정계수"
                    ],
                    correct: 1,
                    explanation: "SW사업 대가산정 가이드(2024)에 따라 규모 보정계수 및 애플리케이션 복잡도 보정계수가 적용될 수 있습니다."
                },
                {
                    question: "Function Point 측정의 주요 목적이 아닌 것은?",
                    options: [
                        "소프트웨어 개발 비용 산정",
                        "소프트웨어 유지관리 비용 산정",
                        "소프트웨어 재개발 자원 소요 산정",
                        "소프트웨어 코딩 스타일 평가"
                    ],
                    correct: 3,
                    explanation: "Function Point는 소프트웨어 개발, 유지관리 및 재개발을 위한 비용과 자원 소요 산정이 가능합니다. 코딩 스타일 평가는 Function Point의 목적이 아닙니다."
                },
                {
                    question: "데이터 기능과 트랜잭션 기능을 구분하는 기준은?",
                    options: [
                        "데이터의 크기와 복잡도",
                        "데이터 저장 여부와 처리 로직 유무",
                        "내부/외부 시스템 구분",
                        "실시간/배치 처리 구분"
                    ],
                    correct: 1,
                    explanation: "데이터 기능(ILF, EIF)은 데이터 저장과 관련되고, 트랜잭션 기능(EI, EO, EQ)은 데이터 처리 로직과 관련됩니다."
                }
            ],
            module03: [                
                {
                    question: "프로젝트 계획서의 정의로 가장 적절한 것은?",
                    options: ["프로젝트 결과물을 기록한 문서", "프로젝트 수행에 필요한 목표, 일정, 예산, 자원, 위험 요소 등을 문서화한 공식 문서", "프로젝트 팀원의 역할을 정의한 문서", "프로젝트 완료 후 평가 결과를 담은 문서"],
                    correct: 1,
                    explanation: "프로젝트 계획서는 프로젝트 수행에 필요한 목표, 일정, 예산, 자원, 위험 요소 등을 문서화한 공식 문서로, 프로젝트의 성공적인 수행을 위한 명확한 로드맵을 제공합니다."
                },
                {
                    question: "WBS(Work Breakdown Structure)의 정의로 올바른 것은?",
                    options: ["프로젝트 예산을 분할한 구조도", "프로젝트 범위와 일정을 세부적으로 나눈 작업 분할 구조도", "프로젝트 팀원의 조직도", "프로젝트 위험 요소 분석표"],
                    correct: 1,
                    explanation: "WBS는 프로젝트 범위와 일정을 세부적으로 나눈 작업 분할 구조도로, 프로젝트 목표 달성을 위해 필요한 활동과 업무를 계층으로 구조화하고 관리 가능한 수준으로 세분화합니다."
                },
                {
                    question: "WBS의 목적에 해당하지 않는 것은?",
                    options: ["프로젝트 범위 정의 및 명확화", "관리 용이성 확보", "고객 만족도 조사", "책임 할당 및 의사소통"],
                    correct: 2,
                    explanation: "WBS의 목적은 프로젝트 범위 정의, 관리 용이성 확보, 책임 할당 및 의사소통, 성과 측정 및 추적, 리스크 식별 및 관리, 프로젝트 통제 및 변경 관리입니다. 고객 만족도 조사는 WBS의 직접적인 목적이 아닙니다."
                },
                {
                    question: "현행 시스템 분석의 정의로 가장 적절한 것은?",
                    options: ["새로운 시스템을 설계하는 과정", "현행 시스템 및 업무를 비즈니스와 데이터 관점에서 분석하여 이해하는 과정", "시스템 성능을 개선하는 과정", "사용자 교육을 계획하는 과정"],
                    correct: 1,
                    explanation: "현행 시스템 분석은 현행 시스템 및 업무를 비즈니스와 데이터 관점에서 분석하여 이해하는 과정으로, 업무 영역의 핵심 프로세스를 파악하고 향후 데이터 분석 및 전환 자료로 활용합니다."
                },
                {
                    question: "현행 업무 분석에서 사용되는 방법이 아닌 것은?",
                    options: ["사용자 인터뷰", "역공학(Reverse Engineering) 분석", "코드 리뷰", "현행 업무 분석서 작성"],
                    correct: 2,
                    explanation: "현행 업무 분석 방법에는 사용자 인터뷰(업무 전문가와의 심층 대화), 역공학 분석(기존 시스템 분석), 현행 업무 분석서 작성이 포함됩니다. 코드 리뷰는 직접적인 현행 업무 분석 방법이 아닙니다."
                },
                {
                    question: "IEEE 표준용어집(1990)에 따른 요구사항의 정의는?",
                    options: ["시스템이 제공해야 하는 기능", "문제를 해결하거나 목적을 달성하기 위하여 사용자가 필요로 하는 조건 또는 기능", "개발자가 구현해야 하는 사양", "고객이 원하는 결과물"],
                    correct: 1,
                    explanation: "IEEE 표준용어집(1990)에 따르면, 요구사항은 '문제를 해결하거나 목적을 달성하기 위하여 사용자가 필요로 하는 조건 또는 기능'으로 정의됩니다."
                },
                {
                    question: "요구사항 도출이 어려운 이유에 해당하지 않는 것은?",
                    options: ["고객의 지식 부족", "참여 부족", "기술의 복잡성", "의사소통 방법 및 스킬 부족"],
                    correct: 2,
                    explanation: "요구사항 도출이 어려운 이유로는 고객의 지식 부족, 참여 부족, 범위 및 베이스라인 확정 부담, 의사소통 스킬 부족, 업무 전문가 부족, 시간 및 일정 부족 등이 있습니다. 기술의 복잡성은 직접적인 요구사항 도출의 어려움이 아닙니다."
                },
                {
                    question: "요구사항 도출 절차의 올바른 순서는?",
                    options: ["요구사항 검토 → 요구사항 수집 → 요구사항 정의", "요구사항 수집 → 요구사항 정의 → 요구사항 검토", "요구사항 정의 → 요구사항 수집 → 요구사항 검토", "요구사항 수집 → 요구사항 검토 → 요구사항 정의"],
                    correct: 1,
                    explanation: "요구사항 도출 절차는 요구사항 수집 → 요구사항 정의 → 요구사항 검토 순서로 진행됩니다. 먼저 수집하고, 정의한 후, 검토하는 것이 논리적 순서입니다."
                },
                {
                    question: "요구사항 수집 기법에 해당하지 않는 것은?",
                    options: ["인터뷰", "워크숍", "프로토타이핑", "데이터 마이그레이션"],
                    correct: 3,
                    explanation: "요구사항 수집 기법에는 인터뷰, 설문조사, 워크숍, 벤치마킹, 사용자 시나리오, 프로토타이핑, 브레인스토밍, Use Case 분석, 역공학 분석 등이 있습니다. 데이터 마이그레이션은 시스템 구축 단계의 활동입니다."
                },
                {
                    question: "Standish Report와 Boehm이 언급한 프로젝트 실패의 주요 원인은?",
                    options: ["기술적 복잡성", "예산 부족", "요구사항 관련 문제", "인력 부족"],
                    correct: 2,
                    explanation: "Standish Report에 따르면 '프로젝트 실패는 대부분 요구사항에 관련된 문제로 인한 것'이며, Boehm은 '프로젝트 실패 제1원인은 고객 니즈 이해 부족으로 인한 요구사항 변경'이라고 하여 요구사항 관리의 중요성을 강조했습니다."
                },
                {
                    question: "API의 REST 아키텍처에서 사용되는 HTTP 메서드 중 데이터를 수정할 때 주로 사용되는 것은?",
                    options: ["GET", "POST", "PUT", "DELETE"],
                    correct: 2,
                    explanation: "PUT은 REST API에서 기존 리소스를 수정하거나 업데이트할 때 사용되는 HTTP 메서드입니다. GET은 조회, POST는 생성, DELETE는 삭제에 사용됩니다."
                },
                {
                    question: "데이터베이스에서 ACID 속성에 해당하지 않는 것은?",
                    options: ["Atomicity (원자성)", "Consistency (일관성)", "Isolation (독립성)", "Durability (지속성)", "Availability (가용성)"],
                    correct: 4,
                    explanation: "ACID는 Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(지속성)의 4가지 속성을 말합니다. Availability(가용성)는 CAP 정리의 구성 요소입니다."
                },
                {
                    question: "사이버 보안에서 '피싱(Phishing)'이란?",
                    options: ["네트워크 속도를 측정하는 도구", "악성 코드의 한 종류", "개인정보를 속여서 빼내는 사회공학적 공격", "데이터베이스 최적화 기법"],
                    correct: 2,
                    explanation: "피싱(Phishing)은 가짜 이메일이나 웹사이트를 통해 사용자를 속여 개인정보나 금융정보를 빼내는 사회공학적 공격 기법입니다."
                },
                {
                    question: "DevOps에서 CI/CD의 'CI'는 무엇을 의미하나요?",
                    options: ["Code Integration", "Continuous Integration", "Central Intelligence", "Computer Interface"],
                    correct: 1,
                    explanation: "CI는 Continuous Integration(지속적 통합)을 의미합니다. 개발자들이 코드 변경사항을 정기적으로 메인 브랜치에 통합하여 통합 문제를 조기에 발견하고 해결하는 개발 방법론입니다."
                },
                {
                    question: "빅데이터의 3V 특성에 해당하지 않는 것은?",
                    options: ["Volume (양)", "Velocity (속도)", "Variety (다양성)", "Visibility (가시성)"],
                    correct: 3,
                    explanation: "빅데이터의 3V는 Volume(데이터의 양), Velocity(데이터 처리 속도), Variety(데이터의 다양성)을 의미합니다. Visibility는 빅데이터의 기본 특성에 포함되지 않습니다."
                },
                {
                    question: "블록체인에서 '합의 알고리즘'의 역할은?",
                    options: ["데이터를 암호화하는 것", "네트워크 참여자들이 동일한 블록을 인정하도록 하는 것", "거래 수수료를 계산하는 것", "사용자 인증을 처리하는 것"],
                    correct: 1,
                    explanation: "합의 알고리즘은 분산된 블록체인 네트워크에서 모든 참여자가 동일한 블록과 거래 내역에 대해 합의하도록 하는 메커니즘입니다. 대표적으로 PoW, PoS 등이 있습니다."
                },
                {
                    question: "소프트웨어 개발에서 '애자일(Agile) 방법론'의 핵심 가치가 아닌 것은?",
                    options: ["개인과 상호작용", "작동하는 소프트웨어", "고객과의 협력", "완벽한 문서화"],
                    correct: 3,
                    explanation: "애자일 선언문에서는 '포괄적인 문서보다 작동하는 소프트웨어'를 가치로 합니다. 완벽한 문서화보다는 실제 작동하는 소프트웨어와 고객과의 소통을 중시합니다."
                }  
            ],
            module01: [
                {
                    question: "프로세스 모델링의 가장 정확한 정의는?",
                    options: [
                        "단순히 다이어그램을 그리는 작업",
                        "주요 비즈니스 프로세스에 대한 데이터 기반의 시각화 과정",
                        "시스템 코딩을 위한 설계서 작성",
                        "조직도를 만드는 과정"
                    ],
                    correct: 1,
                    explanation: "프로세스 모델링은 '주요 비즈니스 프로세스에 대한 데이터 기반의 시각화 과정'으로, 단순한 다이어그램 작성을 넘어 워크플로우를 이해하고, 분석하며, 개선하는 포괄적인 활동입니다."
                },
                {
                    question: "프로세스 모델링의 핵심 중요성에 해당하지 않는 것은?",
                    options: [
                        "프로세스 최적화",
                        "의사소통과 협업 증진",
                        "개발 인력 확보",
                        "위험 관리"
                    ],
                    correct: 2,
                    explanation: "프로세스 모델링의 핵심 중요성은 프로세스 최적화, 의사소통과 협업 증진, 위험 관리, 프로세스 자동화입니다. 개발 인력 확보는 프로세스 모델링의 직접적인 목적이 아닙니다."
                },
                {
                    question: "SDLC에서 프로세스 모델링이 수행하는 역할로 옳지 않은 것은?",
                    options: [
                        "요구사항 수집 및 분석 단계에서 사용자 요구사항 시각화",
                        "설계 단계에서 시스템 구조와 데이터 흐름 표현",
                        "개발 단계에서 코드 자동 생성",
                        "테스트 단계에서 테스트 케이스 설계 지원"
                    ],
                    correct: 2,
                    explanation: "프로세스 모델링은 SDLC의 모든 단계에서 중요한 역할을 하지만, 코드를 자동으로 생성하는 것은 아닙니다. 개발 단계에서는 설계된 모델을 개발자의 구현 참고자료로 활용합니다."
                },
                {
                    question: "DHL의 프로세스 모델링 성공 사례에서 도입한 '허브 앤 스포크' 모델의 개선과 함께 통합한 것은?",
                    options: [
                        "다중 모달 운송(Multimodal Transport)",
                        "원격 근무 시스템",
                        "고객 서비스 센터",
                        "재고 관리 시스템"
                    ],
                    correct: 0,
                    explanation: "DHL은 기존 '허브 앤 스포크' 모델을 개선하고 '다중 모달 운송(Multimodal Transport)'을 통합하여 지역 간 연결성을 강화하고 배송 시간을 단축했습니다."
                },
                {
                    question: "DHL의 'Resilience360' 플랫폼과 IoT 기반 추적 시스템의 주요 목적은?",
                    options: [
                        "비용 절감을 위한 운송 경로 단축",
                        "실시간으로 위험 요인을 예측하고 경로 변경",
                        "고객 개인정보 수집 및 분석",
                        "경쟁사 동향 파악"
                    ],
                    correct: 1,
                    explanation: "DHL의 'Resilience360' 플랫폼과 IoT 기반 추적 시스템은 실시간으로 위험 요인을 예측하고 경로를 변경하며, 고객에게 투명한 배송 상태를 제공하는 실시간 데이터 기반 프로세스 구현을 목적으로 합니다."
                },
                {
                    question: "DHL의 GoGreen 프로그램에서 탄소 배출량 감축을 위해 도입한 방법이 아닌 것은?",
                    options: [
                        "전기차 및 하이브리드 차량 도입",
                        "드론을 활용한 배송",
                        "배송 경로 최적화",
                        "포장재 무게 증가"
                    ],
                    correct: 3,
                    explanation: "DHL의 GoGreen 프로그램은 전기차, 하이브리드 차량, 드론 도입 및 배송 경로 최적화를 통해 탄소 배출량을 감축했습니다. 포장재 무게 증가는 환경 친화적 목표와 반대됩니다."
                },
                {
                    question: "N사 SCM 솔루션 도입 실패 사례의 주요 원인이 아닌 것은?",
                    options: [
                        "프로세스 설계와 실제 운영 간의 불일치",
                        "데이터 품질 문제",
                        "높은 시스템 구축 비용",
                        "사용자 교육 및 변화 관리 실패"
                    ],
                    correct: 2,
                    explanation: "N사의 실패 원인은 프로세스 설계와 실제 운영 간의 불일치, 데이터 품질 문제, 과도한 자동화 의존, 사용자 교육 실패, 협업 실패 등이며, 높은 구축 비용은 주요 실패 원인으로 언급되지 않았습니다."
                },
                {
                    question: "N사 실패 사례에서 '기존 공급망 프로세스를 충분히 분석하지 않은 상태'에서 이루어진 것은?",
                    options: [
                        "인력 채용",
                        "솔루션의 신속한 도입",
                        "예산 승인",
                        "교육 프로그램 실시"
                    ],
                    correct: 1,
                    explanation: "N사는 기존 공급망 프로세스를 충분히 분석하지 않은 상태에서 솔루션의 신속한 도입을 이루어져 프로세스 설계와 실제 운영 간의 불일치가 발생했습니다."
                },
                {
                    question: "프로세스 모델링을 통한 자동화 구현에서 가장 중요한 선행 작업은?",
                    options: [
                        "최신 기술 도입",
                        "프로세스 시각화 및 표준화",
                        "인력 감축 계획 수립",
                        "시스템 성능 향상"
                    ],
                    correct: 1,
                    explanation: "프로세스 자동화를 효과적으로 구현하기 위해서는 먼저 프로세스 시각화 및 표준화가 선행되어야 합니다."
                },
                {
                    question: "DHL의 성공 요인 중 '지역별 맞춤형 전략'과 함께 유지한 것은?",
                    options: [
                        "중앙집중식 관리",
                        "글로벌 네트워크",
                        "단일 운송 수단",
                        "표준화된 서비스"
                    ],
                    correct: 1,
                    explanation: "DHL은 글로벌 네트워크를 유지하면서도 지역별 맞춤형 전략을 도입하여 성공을 이루었습니다."
                }
            ],
            module02: [
                {
                    question: "RFP(제안요청서)의 가장 정확한 정의는?",
                    options: [
                        "발주기관의 내부 검토 문서",
                        "발주기관이 해결하고자 하는 현안에 대한 요구사항을 체계적으로 정리하여 외부에 공식적으로 제안을 요청하는 문서",
                        "제안사가 작성하는 사업 계획서",
                        "계약서 초안"
                    ],
                    correct: 1,
                    explanation: "RFP는 발주기관이 해결하고자 하는 현안에 대한 요구사항을 체계적으로 정리하여 외부(공개입찰을 목적)에 공식적으로 제안을 요청하는 문서입니다."
                },
                {
                    question: "RFP의 주요 목적이 아닌 것은?",
                    options: [
                        "발주사가 요구하는 제품·서비스·시스템 등을 공급업체에 개발·납품 요청",
                        "제안사의 능력 검증 방법 및 평가 지표 제시",
                        "최저가 업체 선정",
                        "제안서 비교 평가의 용이성 확보"
                    ],
                    correct: 2,
                    explanation: "RFP의 주요 목적은 요구사항 전달, 제안사 능력 검증, 평가 기준 제시 등이며, 단순히 최저가 업체를 선정하는 것이 목적은 아닙니다."
                },
                {
                    question: "RFP 기본 설계에서 현행 시스템의 문제점과 개선 필요성을 명시하는 부분은?",
                    options: [
                        "목표 시스템 (To-Be) 개요",
                        "분석 (As-Is) 및 문제점 (Pain Points)",
                        "주요 기능 정의",
                        "성능/보안/기술적 제약 조건"
                    ],
                    correct: 1,
                    explanation: "분석 (As-Is) 및 문제점 (Pain Points) 부분에서 현행 시스템의 문제점과 개선 필요성을 명시합니다."
                },
                {
                    question: "RFP 작성 시 '정량적 목표'를 권장하는 부분은?",
                    options: [
                        "분석 (As-Is) 및 문제점",
                        "목표 시스템 (To-Be) 개요",
                        "주요 기능 정의",
                        "데이터 요구사항"
                    ],
                    correct: 1,
                    explanation: "목표 시스템 (To-Be) 개요 부분에서 기대효과를 기술할 때 정량적 목표를 권장합니다. 예: '고객 만족도 10% 및 신규 고객 5% 증가 목표'"
                },
                {
                    question: "RFP 작성 시 유의사항으로 옳지 않은 것은?",
                    options: [
                        "What 중심으로 작성하고 How는 제안 유도",
                        "과도한 기술 제한 지양으로 제안의 유연성 확보",
                        "구체적인 구현 방법까지 상세히 명시",
                        "시각자료 적극 활용"
                    ],
                    correct: 2,
                    explanation: "RFP 작성 시에는 What(무엇을) 중심으로 작성하고 How(어떻게)는 제안사의 창의적 제안을 유도해야 합니다. 구체적인 구현 방법까지 상세히 명시하면 제안의 유연성을 해칠 수 있습니다."
                },
                {
                    question: "제안서 작성 시 가장 먼저 명확히 해야 하는 것은?",
                    options: [
                        "예상 비용",
                        "핵심 메시지",
                        "기술 스펙",
                        "일정 계획"
                    ],
                    correct: 1,
                    explanation: "제안서 작성 시에는 제안서 전체를 관통하는 단 하나의 핵심 메시지를 먼저 명확히 제시해야 합니다."
                },
                {
                    question: "제안서에서 고객 문제를 정의할 때 포함해야 할 내용이 아닌 것은?",
                    options: [
                        "고객이 겪는 어려움과 문제점",
                        "문제에 대한 깊은 이해와 공감 표현",
                        "경쟁사의 유사한 문제점",
                        "구체적인 업무 손실 현황"
                    ],
                    correct: 2,
                    explanation: "제안서에서는 해당 고객이 겪는 어려움과 문제점에 집중해야 하며, 경쟁사의 문제점을 언급하는 것은 적절하지 않습니다."
                },
                {
                    question: "제안서의 차별화된 강점 부각에서 강조해야 할 것은?",
                    options: [
                        "일반적인 업계 동향",
                        "경쟁사 대비 독보적인 강점과 기술력",
                        "표준적인 서비스 내용",
                        "범용적인 솔루션 특징"
                    ],
                    correct: 1,
                    explanation: "제안서에서는 경쟁사 대비 독보적인 강점, 기술력, 경험 등을 명확히 제시하여 차별화를 부각해야 합니다."
                },
                {
                    question: "제안서에서 피해야 할 작성 방식은?",
                    options: [
                        "고객 맞춤형 내용 구성",
                        "간결하고 명확한 문장 사용",
                        "일반적인 내용 나열",
                        "구체적인 실행 계획 제시"
                    ],
                    correct: 2,
                    explanation: "제안서는 일반적인 내용을 나열하는 것이 아닌, 해당 고객의 특성과 요구사항에 맞춰 맞춤형으로 구성해야 합니다."
                },
                {
                    question: "제안서 마지막 부분에 반드시 포함해야 하는 것은?",
                    options: [
                        "감사 인사",
                        "회사 소개",
                        "명확한 Call to Action (행동 촉구)",
                        "참고 자료 목록"
                    ],
                    correct: 2,
                    explanation: "제안서 마지막에는 고객이 다음 단계로 무엇을 하길 바라는지 명확한 Call to Action(행동 촉구)을 제시해야 합니다."
                }
            ]
        };

        let currentModule = '';
        let currentQuestionIndex = 0;
        let score = 0;
        let selectedAnswer = null;
        let answered = false;
        
        function startQuiz(moduleId, event) {
            currentModule = moduleId;
            currentQuestionIndex = 0;
            score = 0;
            selectedAnswer = null;
            answered = false;

            document.getElementById('intro').style.display = 'none';
            document.getElementById('quiz-container').classList.add('active');
            document.getElementById('results').style.display = 'none';
            
            document.querySelectorAll('.module-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            updateQuestion();
        }

        function updateQuestion() {
            const questions = quizData[currentModule];
            if (!questions) {
                console.error(`'${currentModule}'에 해당하는 퀴즈 데이터가 없습니다.`);
                alert("퀴즈 데이터를 불러오는 데 실패했습니다. 다시 시도해주세요.");
                restartQuiz();
                return;
            }
            const question = questions[currentQuestionIndex];
            
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            
            document.getElementById('current-question').textContent = currentQuestionIndex + 1;
            document.getElementById('total-questions').textContent = questions.length;
            
            const questionContainer = document.getElementById('question-container');
            questionContainer.innerHTML = `
                <h3>${question.question}</h3>
                <div class="options">
                    ${question.options.map((option, index) => `
                        <div class="option" onclick="selectAnswer(${index})">${option}</div>
                    `).join('')}
                </div>
                <div class="explanation" id="explanation">
                    <h4>💡 정답 및 해설</h4>
                    <p><strong>정답:</strong> ${question.options[question.correct]}</p>
                    <p><strong>해설:</strong> ${question.explanation}</p>
                </div>
            `;
            
            document.getElementById('next-btn').disabled = true;
            answered = false;
        }

        function selectAnswer(index) {
            if (answered) return;
            
            selectedAnswer = index;
            answered = true;
            
            const questions = quizData[currentModule];
            const question = questions[currentQuestionIndex];
            const options = document.querySelectorAll('.option');
            
            options.forEach(option => option.style.pointerEvents = 'none');
            
            options[question.correct].classList.add('correct');
            if (selectedAnswer !== question.correct) {
                options[selectedAnswer].classList.add('incorrect');
            } else {
                score++;
            }
            
            document.getElementById('explanation').classList.add('show');
            
            document.getElementById('next-btn').disabled = false;
            
            if (currentQuestionIndex === questions.length - 1) {
                document.getElementById('next-btn').textContent = '결과 보기';
            }
        }

        function nextQuestion() {
            const questions = quizData[currentModule];
            
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                updateQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            const questions = quizData[currentModule];
            const percentage = Math.round((score / questions.length) * 100);
            
            let grade, gradeClass, message;
            if (percentage >= 90) {
                grade = '우수!';
                gradeClass = 'excellent';
                message = '훌륭합니다! IT 지식이 매우 뛰어나시네요! 🎉';
            } else if (percentage >= 70) {
                grade = '양호!';
                gradeClass = 'good';
                message = '잘 하셨습니다! 좋은 IT 지식을 가지고 계시네요! 👍';
            } else if (percentage >= 50) {
                grade = '보통';
                gradeClass = 'average';
                message = '괜찮습니다! 조금 더 학습하시면 더 좋을 것 같아요! 📚';
            } else {
                grade = '개선 필요';
                gradeClass = 'poor';
                message = '더 열심히 공부해보세요! 화이팅! 💪';
            }
            
            // ✨ 수정된 부분: 모든 모듈 이름을 동적으로 가져오도록 변경
            const moduleTitles = {
                'module01': '프로세스 모델링 기초',
                'module02': 'RFP 및 제안서 작성',
                'module03': '프로세스 모델링 개요',
                'module04': '프로세스 모델링',
                'module05': 'Function Point',
                'module06': 'SW 테스트',
                'module07': 'SW 개발방법론'
            };
            const moduleName = moduleTitles[currentModule] || '퀴즈'; // 현재 모듈 ID로 이름을 찾음
            
            document.getElementById('quiz-container').classList.remove('active');
            document.getElementById('results').style.display = 'block';
            document.getElementById('results').innerHTML = `
                <h2>🎯 퀴즈 완료!</h2>
                <p><strong>${moduleName}</strong> 모듈 결과</p>
                <div class="score ${gradeClass}">${score}/${questions.length}</div>
                <p><strong>${percentage}% (${grade})</strong></p>
                <p>${message}</p>
                <button class="restart-btn" onclick="restartQuiz()">다시 시작</button>
            `;
        }

        function restartQuiz() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('intro').style.display = 'block';
            document.getElementById('quiz-container').classList.remove('active');
            document.querySelectorAll('.module-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('next-btn').textContent = '다음 문제';
        }
    </script>
</body>
</html>
